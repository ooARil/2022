---
# Front matter
lang: ru-RU
title: "Лабораторная работа №1"
subtitle: "Математическое моделирование"
author: "Ильинский Арсений Александрович"

# Formatting
toc-title: "Содержание"
toc: true # Table of contents
toc_depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4paper
documentclass: scrreprt
polyglossia-lang: russian
polyglossia-otherlangs: english
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase
indent: true
pdf-engine: lualatex
header-includes:
  - \usepackage[russian]{babel}
  - \linepenalty=10 # the penalty added to the badness of each line within a paragraph (no associated penalty node) Increasing the value makes tex try to have fewer lines in the paragraph.
  - \interlinepenalty=0 # value of the penalty (node) added after each line of a paragraph.
  - \hyphenpenalty=50 # the penalty for line breaking at an automatically inserted hyphen
  - \exhyphenpenalty=50 # the penalty for line breaking at an explicit hyphen
  - \binoppenalty=700 # the penalty for breaking a line at a binary operator
  - \relpenalty=500 # the penalty for breaking a line at a relation
  - \clubpenalty=150 # extra penalty for breaking after first line of a paragraph
  - \widowpenalty=150 # extra penalty for breaking before last line of a paragraph
  - \displaywidowpenalty=50 # extra penalty for breaking before last line before a display math
  - \brokenpenalty=100 # extra penalty for page breaking after a hyphenated line
  - \predisplaypenalty=10000 # penalty for breaking before a display
  - \postdisplaypenalty=0 # penalty for breaking after a display
  - \floatingpenalty = 20000 # penalty for splitting an insertion (can only be split footnote in standard LaTeX)
  - \raggedbottom # or \flushbottom
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Вспомнить основные команды Git Bash для работы с системой контроля версий git. Выполнить тренировочные задания по работе с проектом(репозиторием) с помощью git.

# План работы

- ## Подготовка
- ## Создание проекта
- ## Внесение изменений
- ## Индексация изменений
- ## Отмена локальных изменений (до индексации)
- ##  Отмена проиндексированных изменений (перед коммитом)
- ## Отмена коммитов
- ## Удаление коммиттов из ветки
- ## Удаление тега oops
- ## Внесение изменений в коммиты
- ## Перемещение файлов
- ##  Второй способ перемещения файлов
- ## Подробнее о структуре
- ## Git внутри: Каталог .git
- ## Работа непосредственно с объектами git
- ## Создание ветки
- ## Навигация по веткам
- ## Изменения в ветке main
- ## Коммит изменений README.md в ветку main
- ## Слияние
- ## Создание конфликта
- ## Разрешение конфликтов
- ##  Сброс ветки style
- ## Сброс ветки main
- ## Перебазирование
- ## Слияние в ветку main
- ##  Клонирование репозиториев
- ## Просмотр клонированного репозитория
- ## Что такое origin?
- ## Удаленные ветки
- ##  Изменение оригинального репозитория
- ## Слияние извлеченных изменений
- ## Добавление ветки наблюдения
- ## Чистые репозитории
- ## Создание чистого репозитория
- ##  Добавление удаленного репозитория
- ##  Отправка изменений
- ##  Извлечение общих изменений


# Выполнение лабораторной работы

## Подготовка к работе с git

Для начала работы необходимо выполнить команды git config, чтобы git узнал ваше имя и электронную почту. Однако, так как я ранее уже использовал git, то просто проверим это с помощью команды git config user.name и git config user.email, которая выводит информацию о имени и электронной почте пользователя соответственно. В ней видно данные пользователя в последних двух строках. (рис. [-@fig:001])

![Информация о пользователе git](image/1.png){#fig:001 width=100%}

Также необходимо установить параметры окончаний строк:

- Настройка core.autocrlf с параметрами true и input делает все переводы строк текстовых файлов в главном репозитории одинаковыми. (рис. [-@fig:002]). 

- Если core.safecrlf установлен в true или warm, git проверяет, если преобразование является обратимым для текущей настройки core.autocrlf. core.safecrlf true - отвержение необратимого преобразования lf<->crlf.

![Установка параметром окончаний строк](image/2.png){#fig:002 width=70%}

Так как по умолчанию, git будет печатать не-ASCII символов в именах файлов в виде восьмеричных последовательностей \nnn. Что бы избежать нечитаемых строк, установим соответствующий флаг. (рис. [-@fig:003])

![Установка флага](image/3.png){#fig:003 width=100%}

## Создание проекта

Создадим пустой каталог hello, затем войдем него и создадим файл с именем hello.html, содержащий приветствие "Hello world!". (рис. [-@fig:004])

![Создание каталога и файла](image/4.png){#fig:004 width=70%}

Чтобы создать git репозиторий из этого каталога, выполним команду git init. (рис. [-@fig:005])

![Создание репозитория](image/5.png){#fig:005 width=100%}

Добавим файл в репозиторий. (рис. [-@fig:006])

![Добавление файла в репозиторий](image/6.png){#fig:006 width=70%}

Используем команду git status, чтобы проверить текущее состояние репозитория. (рис. [-@fig:007])

![Проверка текущего состояния репозитория](image/7.png){#fig:007 width=100%}

## Внесение изменений

Добавим кое-какие HTML-теги к нашему приветствию. Изменим содержимое файла hello.html на:
*<h1>Hello, World!</h1>*
И проверим состояние рабочего каталога. (рис. [-@fig:008])

![Проверка состояния репозитория после изменений](image/8.png){#fig:008 width=100%}

git знает, что файл hello.html был изменен, но при этом эти изменения еще
не зафиксированы в репозитории.

## Индексация изменений

Теперь выполним команду git, чтобы проиндексировать изменения. (рис. [-@fig:009] ). 

![Индексация изменений](image/9.png){#fig:009 width=70%}

А затем проверим состояние репозитория. рис. [-@fig:010])

![Проверка состояния репозитория после индексации](image/10.png){#fig:010 width=100%}

Изменения файла hello.html были проиндексированы. Это означает, что git теперь знает об изменении, но изменение пока не записано в репозиторий. Следующий коммит будет включать в себя проиндексированные изменения.

Сделаем коммит. (рис. [-@fig:011])

![Коммит изменений](image/11.png){#fig:010 width=100%}

Открылся редактор. В первой строке введем комментарий: «Added h1 tag». (рис. [-@fig:012])

![Редактор](image/12.png){#fig:012 width=100%}

Сохраним файл и выйдем из редактора. (рис. [-@fig:013])

![Коммит изменений](image/13.png){#fig:013 width=100%}

Снова проверим состояние. (рис. [-@fig:014])

![Состояние после коммита](image/14.png){#fig:014 width=100%}

Рабочий каталог чистый, можно продолжить работу.

Изменим страницу «Hello, World», чтобы она содержала стандартные теги  *<html>* и *<body>*.
```html
<html>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```
Теперь добавим это изменение в индекс git. (рис. [-@fig:015])

![Текущий статут](image/15.png){#fig:015 width=100%}

Теперь добавим заголовки HTML (секцию *<head>*) к странице «Hello, World».
```html
<html>
  <head>
  </head>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```
Проверим текущий статус. (рис. [-@fig:016])

![Текущий статут](image/16.png){#fig:016 width=100%}

hello.html указан дважды в состоянии. Первое изменение (добавление стандартных тегов) проиндексировано и готово к коммиту. Второе изменение (добавление заголовков HTML) является непроиндексированным. Если бы мы делали коммит сейчас, заголовки не были бы сохранены в репозиторий.

Произведем коммит проиндексированного изменения (значение по умолчанию). (рис. [-@fig:017])

![Первый коммит](image/17.png){#fig:017 width=100%}

Еще раз проверим состояние. (рис. [-@fig:018])

![Состояние после коммита](image/18.png){#fig:018 width=100%}

Состояние команды говорит о том, что hello.html имеет незафиксированные изменения, но уже не в буферной зоне.

Теперь добавим второе изменение в индекс, а затем проверим состояние. (рис. [-@fig:019])

![Состояние после проиндексированного изменения](image/19.png){#fig:019 width=100%}

В качестве файла для добавления, мы используем текущий каталог (.). Это краткий и удобный путь для добавления всех изменений в файлы текущего каталога и его подкаталоги. Но поскольку он добавляет все, не лишним будет проверить состояние перед запуском add, просто чтобы убедиться, что мы не добавили какой-то файл, который добавлять было не нужно.

Второе изменение было проиндексировано и готово к коммиту. Выполним коммит. (рис. [-@fig:020])

![Второй коммит](image/20.png){#fig:020 width=100%}

Получим список произведенных изменений: (рис. [-@fig:021])

![Список изменений](image/21.png){#fig:021 width=100%}

Однострочный формат истории: (рис. [-@fig:022])

![Список изменений в однострочном формате](image/22.png){#fig:022 width=100%}

Получив хэши предыдущих версий, изучил данные лога и нашел хэш для первого коммита - 6ca1299...

Использовал этот хэш-код для перехода к изначальному снимку репозитория с помощью команды checkout. (рис. [-@fig:023])

![Переход к изначальному снимку репозитория](image/23.png){#fig:023 width=100%}

И проверил содержимое файла hello.html. (рис. [-@fig:024])

![Содержимое файла hello.html](image/24.png){#fig:024 width=100%}

Затем вернулся к последней версии ветки main. (рис. [-@fig:025])

![Переход к актуальной версии репозитория](image/25.png){#fig:025 width=100%}

И проверил содержимое файла hello.html. (рис. [-@fig:026])

![Актуальная версия hello.html](image/26.png){#fig:026 width=100%}

Назовем текущую версию страницы hello первой (v1). Для этого создадим тег с помощью команды git tag v1. Теперь текущая версия страницы называется v1. (рис. [-@fig:027])

![Тэг для текущей версии](image/27.png){#fig:027 width=100%}

Давайте создадим тег для версии, которая идет перед текущей версией и назовем еe v1-beta. В первую очередь нам надо переключиться на предыдущую версию. Вместо поиска до хэш, мы будем использовать ^, обозначающее «родитель v1». Вместо обозначения v1^ можно использовать v1~1. Это обозначение можно определить как «первую версию предшествующую
v1». (рис. [-@fig:028])

![Переключимся на предыдущую версию](image/28.png){#fig:028 width=100%}

Это версия c тегами <html> и <body>, но еще пока без <head>. Давайте сделаем
ее версией v1-beta с помощью команды git tag v1-beta. (рис. [-@fig:029])

![Тег для предыдущей версии](image/29.png){#fig:029 width=100%}

Теперь попробуем попереключаться между двумя отмеченными версиями командой git checkout *имя соответствующего тега*. (рис. [-@fig:030])

![Теги для разных снимков репозитория](image/30.png){#fig:030 width=100%}

Просмотрим доступные теги с помощью команды git tag.

Также теги можно посмотреть в логе. (рис. [-@fig:031])

![Доступные теги](image/31.png){#fig:031 width=100%}

## Отмена локальных изменений (до индексации)

Иногда случается, что вы изменили файл в рабочем каталоге, и хотите отменить
последние коммиты. С этим справится команда git checkout.

Внесем изменение в файл hello.html в виде нежелательного комментария.

```html
<html>
  <head>
  </head>
  <body>
    <h1>Hello, World!</h1>
    <!-- This is a bad comment. We want to revert it. -->
  </body>
</html>
```

Сначала проверим состояние рабочего каталога. (рис. [-@fig:032])

![Состояние рабочего каталога после изменений](image/32.png){#fig:032 width=100%}

Мы видим, что файл hello.html был изменен, но еще не проиндексирован.

Используем команду git checkout для переключения версии файла hello.html в репозитории. (рис. [-@fig:033], рис. [-@fig:034])

![Переключении версии](image/33.png){#fig:033 width=100%}

![Файл hello.html после переключения](image/34.png){#fig:034 width=100%}

Команда git status показывает нам, что не было произведено никаких изменений, не зафиксированных в рабочем каталоге.

## Отмена проиндексированных изменений (перед коммитом)

Внесем изменение в файл hello.html в виде нежелательного комментария. 

```html
<html>
  <head>
    <!-- This is an unwanted but staged comment -->
  </head>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```

Проиндексируем это изменение. (рис. [-@fig:035])

![Индексация изменений](image/35.png){#fig:035 width=100%}

Проверим состояние после нежелательного изменения. (рис. [-@fig:036])

![Состояние после индексации](image/36.png){#fig:036 width=100%}

Состояние показывает, что изменение было проиндексировано и готово к коммиту.

К счастью, вывод состояния показывает нам именно то, что мы должны сделать
для отмены индексации изменения.

Команда git reset сбрасывает буферную зону к HEAD. Это очищает буферную
зону от изменений, которые мы только что проиндексировали. (рис. [-@fig:037])

![Возвращение к моменту до индексации](image/37.png){#fig:037 width=100%}

Команда git reset (по умолчанию) не изменяет рабочий каталог. Поэтому рабочий каталог все еще содержит нежелательный комментарий. Мы можем использовать команду git checkout, чтобы удалить нежелательные изменения в
рабочем каталоге. (рис. [-@fig:038])

![Удаление нежелательных изменений](image/38.png){#fig:038 width=100%}

Наш рабочий каталог опять чист.

## Отмена коммитов

Иногда мы понимаем, что новые коммиты являются неверными, и хотим их отменить. Есть несколько способов решения этого вопроса, здесь мы будем использовать самый безопасный.

Мы отменим коммит путем создания нового коммита, отменяющего нежелательные изменения.

Изменим файл hello.html на:

```html
<html>
  <head>
  </head>
  <body>
    <h1>Hello, World!</h1>
    <!-- This is an unwanted but committed change -->
  </body>
</html>
```

Проиндексируем его и выполним коммит. (рис. [-@fig:039])

![Коммит изменений](image/39.png){#fig:039 width=100%}

Чтобы отменить коммит, нам необходимо сделать коммит, который удаляет изменения, сохраненные нежелательным коммитом. (рис. [-@fig:040])

![Отмена коммита](image/40.png){#fig:040 width=100%}

Так как мы отменили самый последний произведенный коммит, мы смогли
использовать HEAD в качестве аргумента для отмены. Мы можем отменить любой произвольной коммит в истории, указав его хэш-значение.

Проверка лога показывает нежелательные и отмененные коммиты в наш репозиторий. (рис. [-@fig:041])

![Лог после отмены коммита](image/41.png){#fig:041 width=100%}

## Удаление коммитов из ветки

git revert является мощной командой, которая позволяет отменить любые коммиты в репозиторий. Однако, и оригинальный и «отмененный» коммиты видны в истории ветки (при использовании команды git log).

Часто мы делаем коммит, и сразу понимаем, что это была ошибка. Было бы неплохо иметь команду «возврата», которая позволила бы нам сделать вид, что неправильного коммита никогда и не было. Команда «возврата» даже предотвратила бы появление нежелательного коммита в истории git log.

При получении ссылки на коммит (т.е. хэш, ветка или имя тега), команда git
reset:
- перепишет текущую ветку, чтобы она указывала на нужный коммит;
- опционально сбросит буферную зону для соответствия с указанным коммитом;
- опционально сбросит рабочий каталог для соответствия с указанным коммитом.

Давайте сделаем быструю проверку нашей истории коммитов. (рис. [-@fig:042])

![История коммитов](image/42.png){#fig:042 width=100%}

Мы видим, что два последних коммита в этой ветке — «Oops» и «Revert Oops».
Давайте удалим их с помощью сброса.

Но прежде чем удалить коммиты, давайте отметим последний коммит тегом, чтобы потом можно было его найти. (рис. [-@fig:043])

![Тег для последнего коммита](image/43.png){#fig:043 width=100%}

Глядя на историю лога, мы видим, что коммит с тегом «v1» является коммитом, предшествующим ошибочному коммиту. Давайте сбросим ветку до этой точки. Поскольку ветка имеет тег, мы можем использовать имя тега в команде сброса (если она не имеет тега, мы можем использовать хэш-значение). (рис. [-@fig:044])

![Сброс ветки до коммита v1](image/44.png){#fig:044 width=100%}

Наша ветка main теперь указывает на коммит v1, а коммитов Oops и Revert Oops в ветке уже нет. Параметр --hard указывает, что рабочий каталог должен быть обновлен в соответствии с новым head ветки.

Что же случается с ошибочными коммитами? Оказывается, что коммиты все еще находятся в репозитории. На самом деле, мы все еще можем на них ссылаться. Помните, в начале этого урока мы создали для отмененного коммита тег «oops». Давайте посмотрим на все коммиты. (рис. [-@fig:045])

![Все коммиты](image/45.png){#fig:045 width=100%}

Мы видим, что ошибочные коммиты не исчезли. Они все еще находятся в репозитории. Просто они отсутствуют в ветке main. Если бы мы не отметили их тегами, они по-прежнему находились бы в репозитории, но не было бы никакой возможности ссылаться на них, кроме как при помощи их хэш имен. Коммиты, на которые нет ссылок, остаются в репозитории до тех пор, пока не будет запущен сборщик мусора.

Сброс в локальных ветках, как правило, безопасен. Последствия любой «аварии» как правило, можно восстановить простым сбросом с помощью нужного коммита. Однако, если ветка «расшарена» на удаленных репозиториях, сброс может сбить с толку других пользователей ветки.

## Удаление тега oops

Тег oops свою функцию выполнил. Теперь удалим его и коммиты, на которые он ссылался, сборщиком мусора. (рис. [-@fig:046])

![Удаление тега oops](image/46.png){#fig:046 width=100%}

Тег «oops» больше не будет отображаться в репозитории.

## Внесение изменений в коммиты

Добавим в страницу комментарий автора (свою фамилию).

```html
<!-- Author: Arsenij A. Ilinskij -->
  <html>
    <head>
  </head>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```

Выполним коммит изменений. (рис. [-@fig:047])

![Коммит изменений](image/47.png){#fig:047 width=100%}

Обновим страницу hello, включив в нее email.

```html
<!-- Author: Arsenij A. Ilinskij ( ilinskiyar@gmail.com ) -->
  <html>
    <head>
  </head>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```

Мы действительно не хотим создавать отдельный коммит только ради электронной почты. Давайте изменим предыдущий коммит, включив в него адрес электронной почты. (рис. [-@fig:048])

![Изменение предыдущего коммита](image/48.png){#fig:048 width=100%}

Просмотрим историю изменений. (рис. [-@fig:049])

![История изменений](image/49.png){#fig:049 width=100%}

Мы можем увидеть, что оригинальный коммит «автор» заменен коммитом «автор/email». Этого же эффекта можно достичь путем сброса последнего коммита в ветке, и повторного коммита новых изменений.

## Перемещение файлов

Сейчас мы собираемся создать структуру нашего репозитория. Давайте создадим каталог lib и перенесем файл hello.html в него. (рис. [-@fig:050])

![Перенос файлов с помощью git mv](image/50.png){#fig:050 width=100%}

Перемещая файлы с помощью git mv, мы информируем git о 2 вещах:
- Что файл hello.html был удален.
- Что файл lib/hello.html был создан.
- Оба эти факта сразу же проиндексированы и готовы к коммиту. Команда git
status сообщает, что файл был перемещен.

## Второй способ перемещения файлов

Положительной чертой git является то, что вы можете забыть о версионном контроле до того момента, когда вы готовы приступить к коммиту кода. Что бы случилось, если бы мы использовали командную строку операционной системы для перемещения файлов вместо команды git?

Следующий набор команд идентичен нашим последним действиям. Работы
здесь побольше, но результат тот же.
Мы могли бы выполнить:
```bash
mkdir lib
mv hello.html lib
git add lib/hello.html
git rm hello.html
```
Давайте сделаем коммит этого перемещения: (рис. [-@fig:051])

![Коммит переноса файла](image/51.png){#fig:051 width=100%}

## Подробнее о структуре

Cоздадим (рис. [-@fig:052]) и добавим файл index.html в наш репозиторий. 

```html
<html>
  <body>
    <iframe src="lib/hello.html" width="200" height="200" />
  </body>
</html>
```

![Файл index.html](image/52.png){#fig:052 width=100%}

Проиндексируем и закоммитим изменения. (рис. [-@fig:053])

![Коммит файла index.html](image/53.png){#fig:053 width=100%}

Теперь при открытии index.html, мы видим кусок страницы hello в маленьком окошке. (рис. [-@fig:054])

![Страница index.html](image/54.png){#fig:054 width=100%}

## Git внутри: Каталог .git

Выполним
```bash
ls -C .git
```
Это каталог, в котором хранится вся информация git. (рис. [-@fig:055])

![Набор каталогов в .git](image/55.png){#fig:055 width=100%}

Выполним
```bash
ls -C .git/objects
```
Мы видим набор каталогов, имена которых состоят из 2 символов. Имена каталогов являются первыми двумя буквами хэша sha1 объекта, хранящегося в git. (рис. [-@fig:056])

![Набор каталогов в .git/objects](image/56.png){#fig:056 width=100%}

Выполним
```bash
ls -C .git/objects/0a
```
Смотрим в один из каталогов с именем из 2 символов. Мы видим файлы с именами из 38 символов. Это файлы, содержащие объекты, хранящиеся в git. Они сжаты и закодированы, поэтому просмотр их содержимого нам мало чем поможет. (рис. [-@fig:057])

![Набор каталогов в .git/objects/47](image/57.png){#fig:057 width=100%}

Выполним
```bash
cat .git/config
```
Это файл конфигурации, создающийся для каждого конкретного проекта. Записи в этом файле будут перезаписывать записи в файле .gitconfig вашего главного каталога, по крайней мере в рамках этого проекта. (рис. [-@fig:058])

![Файл конфигурации проекта](image/58.png){#fig:058 width=100%}

Выполним
```bash
ls .git/refs
ls .git/refs/heads
ls .git/refs/tags
cat .git/refs/tags/v1
```
Вы должны узнавать файлы в подкаталоге тегов. Каждый файл соответствует тегу, ранее созданному с помощью команды git tag. Его содержание — это всего лишь хэш коммита, привязанный к тегу. Каталог heads практически аналогичен, но используется для веток, а не тегов. На данный момент у нас есть только одна ветка, так что все, что вы увидите в этом каталоге – это ветка main. (рис. [-@fig:059])

![Файлы в каталогах refs, refs/heads, refs/ tags, refs/tags/v1 из каталога .git](image/59.png){#fig:059 width=100%}

Выполним
```bash
cat .git/HEAD
```
Файл HEAD содержит ссылку на текущую ветку, в данный момент это должна
быть ветка main. (рис. [-@fig:060])

![Файлы HEAD](image/60.png){#fig:060 width=100%}

## Работа непосредственно с объектами git

Выполним
```bash
git log --max-count=1
```
Эта команда показывает последний коммит в репозитории. (рис. [-@fig:061])

![Последний коммит в репозитории](image/61.png){#fig:061 width=100%}

Выведем последний коммит с помощью SHA1 хэша с помощью команд (рис. [-@fig:062]):
```bash
git cat-file -t <hash>
git cat-file -p <hash>
```
![Информация о последнем коммите](image/62.png){#fig:062 width=100%}

Мы можем вывести дерево каталогов, ссылка на который идет в коммите. Это должно быть описание файлов (верхнего уровня) в нашем проекте (для конкретного коммита). Используем SHA1 хэш(0546109...) из строки «tree», из списка выше. Для этого выполним (рис. [-@fig:063]):
```bash
git cat-file -p 0546109
```
![Дерево каталогов](image/63.png){#fig:063 width=100%}

Выполним то же самое, только с хэшом каталога SHA1 хэш(3659d2b...) из строки «lib», из списка выше. (рис. [-@fig:064]):
```bash
git cat-file -p 3659d2b
```
![Каталог lib](image/64.png){#fig:064 width=100%}

Выполним то же самое, только с хэшом каталога SHA1 хэш(a4f6089...) из строки «hello», из списка выше. (рис. [-@fig:065]):-
```bash
git cat-file -p a4f6089
```
![Файл hello.html](image/65.png){#fig:065 width=70%}

Дойдем до оригинального файла hello.html с самого первого коммита вручную по ссылкам SHA1 хэша. Для этого будем переходить по хэшу parent, пока не дойдем до начального коммита. (рис. [-@fig:067], рис. [-@fig:068])

![Переход к первой версии файла hello.html по хэшам SHA1 часть 1](image/67.png){#fig:067 width=100%}

![Переход к первой версии файла hello.html по хэшам SHA1 часть 2](image/68.png){#fig:068 width=100%}

Оригинальный файл hello.html. (рис. [-@fig:069])

![Оригинальный файл hello.html](image/69.png){#fig:069 width=100%}

## Создание ветки

Пора сделать наш hello world более выразительным. Так как это может занять некоторое время, лучше переместить эти изменения в отдельную ветку, чтобы изолировать их от изменений в ветке main.

Назовем нашу новую ветку «style». Выполним (рис. [-@fig:070]):

![Создание новой ветки style](image/70.png){#fig:070 width=100%}

Команда git status сообщает о том, что в данный момент мы находимся в ветке «style».

Добавим файл стилей style.css. Выполним (рис. [-@fig:071]):
```css
h1 {
  color: red;
}
```

![Создание файла style.css](image/71.png){#fig:071 width=100%}

Проиндексируем его и выполним коммит. (рис. [-@fig:072]):

![Проиндексируем и выполним коммит](image/72.png){#fig:072 width=100%}

Теперь изменим основную страницу. Обновим файл hello.html, чтобы использовать стили style.css.
```html
<!-- Author: Arsenij A. Ilinskij ( ilinskiyar@gmail.com ) -->
<html>
  <head>
  <link type="text/css" rel="stylesheet"
    media="all" href="style.css" />
  </head>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```

Проиндексируем его и выполним коммит. (рис. [-@fig:073]):

![Проиндексируем и выполним коммит](image/73.png){#fig:073 width=100%}

Теперь обновим файл index.html, чтобы он тоже использовал style.css.

```html
<html>
  <head>
    <link type="text/css" rel="stylesheet"
      media="all" href="lib/style.css" />
  </head>
  <body>
    <iframe src="lib/hello.html" width="200" height="200" />
  </body>
</html>
```

Проиндексируем его и выполним коммит. (рис. [-@fig:074]):

![Проиндексируем и выполним коммит](image/74.png){#fig:074 width=100%}

Теперь при открытии index.html, мы видим кусок страницы hello в маленьком окошке с красным цветом шрифта. (рис. [-@fig:075])

![Страница index.html](image/75.png){#fig:075 width=100%}

## Навигация по веткам

Теперь в нашем проекте есть две ветки. Выполним (рис. [-@fig:076]):

![Две ветки в проекте](image/76.png){#fig:076 width=100%}

Используя команду git checkout переключимся на ветку main. (рис. [-@fig:077])

![Переключимся на ветку main](image/77.png){#fig:077 width=100%}

Сейчас мы находимся на ветке main. Это заметно по тому, что файл hello.html не использует стили style.css.

Теперь вернемся к ветке style. Выполним (рис. [-@fig:078]):

![Вернемся к ветке style](image/78.png){#fig:078 width=100%}

Содержимое lib/hello.html подтверждает, что мы вернулись на ветку style.

## Изменения в ветке main

Допустим, пока мы меняли ветку style, кто-то решил обновить ветку main. Они добавили файл README.md.

Создадим файл README в ветке main. Выполним (рис. [-@fig:079]):

![Создадим файл README в ветке main](image/79.png){#fig:079 width=100%}

Добавим в него содержимое *This is the Hello World example from the git tutorial*. (рис. [-@fig:080]):

![Добавим строку в файл README.md](image/80.png){#fig:080 width=100%}


## Сделаем коммит изменений README.md в ветку main

Проиндексируем файл README.md и выполним коммит. (рис. [-@fig:081]):

![Проиндексируем и выполним коммит](image/81.png){#fig:081 width=100%}

Просмотрим отличающиеся ветки. Теперь у нас в репозитории есть две отличающиеся ветки. Просмотрим ветки и их отличия, выполнив (рис. [-@fig:082]):

![Просмотр веток и их отличий](image/82.png){#fig:082 width=100%}

Добавление опции --graph в git log вызывает построение дерева коммитов с помощью простых ASCII символов. Мы видим обе ветки (style и main), и то, что ветка main является текущей HEAD. Общим предшественником обеих веток является коммит «Added index.html». Опция --all гарантированно означает, что мы видим все ветки. По умолчанию показывается только текущая ветка.

## Слияние

Слияние переносит изменения из двух веток в одну. Вернемся к ветке style и сольем main с style, выполнив (рис. [-@fig:083], рис. [-@fig:084]):

![Мерджинг веток main и style](image/83.png){#fig:083 width=100%}

![Мерджинг веток main и style](image/84.png){#fig:084 width=100%}

Путем периодического слияния ветки main с веткой style мы можем переносить из main любые изменения и поддерживать совместимость изменений style с изменениями в основной ветке.

## Создание конфликта

Но что если изменения в ветке main конфликтуют с изменениями в style?

Вернемся в ветку main. (рис. [-@fig:085])

![Вернемся в ветку main](image/85.png){#fig:085 width=100%}

И внесем следующие изменения в файл hello.html. (рис. [-@fig:086])

```html
<!-- Author: Arsenij A. Ilinskij ( ilinskiyar@gmail.com ) -->
<html>
  <head>
    <!-- no style -->
  </head>
  <body>
    <h1>Hello, World! Life is great!</h1>
  </body>
</html>
```

Проиндексируем его и выполним коммит. (рис. [-@fig:086])

![Проидексируем и выполним коммит](image/86.png){#fig:086 width=100%}

Теперь просмотрим ветки, выполнив (рис. [-@fig:087]):

![Обнаружение конфликта](image/87.png){#fig:087 width=100%}

После коммита «Added README» ветка main была объединена с веткой style, но в настоящее время в main есть дополнительный коммит, который не был слит с style. Последнее изменение в main конфликтует с некоторыми изменениями в style.

## Разрешение конфликтов

Теперь вернемся к ветке style и попытаемся объединить ее с новой веткой main, выполнив (рис. [-@fig:088]):

![Мерджинг веток style и main](image/88.png){#fig:088 width=100%}

Теперь, если мы откроем файл lib/hello.html, то мы должны увидеть (рис. [-@fig:089]):

![Обнаружение конфликта в файле hello.html](image/89.png){#fig:089 width=100%}

Можно увидеть, что:

- Первый раздел — версия текущей ветки (style). 

- Второй раздел — версия ветки main.

Для разрешения конфликта, нужно вручную решить проблему, а именно внести изменения в lib/hello.html. (рис. [-@fig:090])

![Решение конфликта в файле hello.html](image/90.png){#fig:090 width=100%}

Сделаем коммит решения конфликта. (рис. [-@fig:091])

![Проиндексируем и выполним коммит](image/91.png){#fig:091 width=100%}

## Сброс ветки style

Вернемся на ветке style к точке перед тем, как мы слили ее с веткой main. Мы можем сбросить ветку к любому коммиту. По сути, это изменение указателя ветки на любую точку дерева коммитов. В этом случае мы хотим вернуться в ветке style в точку перед слиянием с main. Нам необходимо найти последний коммит перед слиянием, для этого выполним (рис. [-@fig:092]):

![Перейдем на ветку style и найдем нужный коммит](image/92.png){#fig:092 width=100%}



Мы видим, что коммит «Updated index.html» ( хэш(d9ac061...) ) был последним на ветке style перед слиянием, поэтому сбросим ветку style к этому коммиту. (рис. [-@fig:093])

![Сбросим ветку style к этому коммиту](image/93.png){#fig:093 width=100%}

Теперь проверим ветку. Найдем лог ветки style. (рис. [-@fig:094])

![Лог ветки style](image/94.png){#fig:094 width=100%}

Можно заметить, что у нас в истории больше нет коммитов слияний.

## Сброс ветки main

Добавив интерактивный режим в ветку main, мы внесли изменения, конфликтующие с изменениями в ветке style. Давайте вернемся в ветку main в точку перед внесением конфликтующих изменений. Для этого выполним (рис. [-@fig:095]):

![Лог ветки main](image/95.png){#fig:095 width=100%}

Коммит «Added README» идет непосредственно перед коммитом конфликтующего интерактивного режима, поэтому мы сбросим ветку main к коммиту «Added README» ( хэш(81e271b..) ). (рис. [-@fig:096])

![Сбросим ветку main к этому коммиту](image/96.png){#fig:096 width=100%}

Посмотрев лог, можно прийти к выводу что, как будто репозиторий был перемотан назад во времени к точке до какого-либо слияния.

## Перебазирование

Рассмотрим различия между слиянием и перебазированием. Для того, чтобы это сделать, нам нужно вернуться в репозиторий в момент до первого слияния ( что мы и сделали в предыдущих 2ух пунктах ), а затем повторить те же действия, но с использованием перебазирования вместо слияния.

Используем команду rebase вместо команды merge. Мы вернулись в точку до первого слияния и хотим перенести изменения из ветки main в нашу ветку style. На этот раз для переноса изменений из ветки main мы будем использовать команду git rebase вместо слияния. (рис. [-@fig:097])

![Перебазирование веток style и main](image/97.png){#fig:097 width=100%}

Конечный результат перебазирования очень похож на результат слияния. Ветка style в настоящее время содержит все свои изменения, а также все изменения ветки main. Однако, дерево коммитов значительно отличается. Дерево коммитов ветки style было переписано таким образом, что ветка main является частью истории коммитов. Это делает цепь коммитов линейной и гораздо более читабельной. 

## Слияние в ветку main

Мы поддерживали соответствие ветки style с веткой main (с помощью rebase), теперь давайте сольем изменения style в ветку main, выполнив (рис. [-@fig:098]):

![Слияние style в main](image/98.png){#fig:098 width=100%}

Поскольку последний коммит ветки main прямо предшествует последнему коммиту ветки style, git может выполнить ускоренное слияние-перемотку. При быстрой перемотке конфликтов быть не может.

Посмотрим логи, выполнив (рис. [-@fig:099]):

![Проверим логи после слияния](image/99.png){#fig:099 width=100%}

Теперь ветки style и main идентичны.

## Клонирование репозиториев

Перейдем в рабочий каталог и сделаем клон нашего репозитория hello. 

Для этого перейдем в «рабочий» каталог. (рис. [-@fig:100])

![Перейдем в рабочий каталог](image/100.png){#fig:100 width=100%}

Теперь создадим клон репозитория. (рис. [-@fig:101])

![Клон репозитория](image/101.png){#fig:101 width=100%}

В вашем «рабочем» каталоге теперь должно быть два репозитория: оригинальный репозиторий «hello» и клонированный репозиторий «cloned_hello». (рис. [-@fig:102])

![Содержимое рабочего каталога](image/102.png){#fig:102 width=100%}

## Просмотр клонированного репозитория

Давайте взглянем на клонированный репозиторий, выполнив (рис. [-@fig:103]):

![Содержимое клонированного репозитория](image/103.png){#fig:103 width=100%}

Мы увидим список всех файлов на верхнем уровне оригинального репозитория README.md, index.html и lib.

Давайте просмотрим историю репозитория, выполнив (рис. [-@fig:104]):

![История клонированного репозитория](image/104.png){#fig:104 width=100%}

Мы видим список всех коммитов в новый репозитории, и более / менее совпадает с историей коммитов в оригинальном репозитории. 

Однако ветки main (HEAD) мы можем увидеть ветки со странными именами (origin/main, origin/style и origin/HEAD).

## Что такое origin?

Выполнив (рис. [-@fig:104]):
```bash
git remote
```

![Имя по умолчанию удаленного репозитория](image/105.png){#fig:105 width=100%}

Мы видим, что клонированный репозиторий знает об имени по умолчанию удаленного репозитория. Давайте посмотрим, можем ли мы получить более подробную информацию об имени по умолчанию, выполнив (рис. [-@fig:105]):
```bash
git remote show origin
```

![Более подробная информации об имени по умолчанию](image/106.png){#fig:106 width=100%}

Удаленные репозитории обычно размещаются на отдельной машине, возможно, централизованном сервере. Однако, как мы видим здесь, они могут с тем же успехом указывать на репозиторий на той же машине. 

## Удаленные ветки

Давайте посмотрим на ветки, доступные в нашем клонированном репозитории. (рис. [-@fig:107])
```bash
git branch
```

![Доступные ветки](image/107.png){#fig:107 width=100%}

Как мы видим, в списке только ветка main. Где ветка style? Команда git branch выводит только список локальных веток по умолчанию.

Для того, чтобы увидеть все ветки, попробуем следующую команду (рис. [-@fig:108]):
```bash
git branch -a
```

![Список всех веток](image/108.png){#fig:108 width=100%}

Git выводит все коммиты в оригинальный репозиторий, но ветки в удаленном репозитории не рассматриваются как локальные.

## Изменение оригинального репозитория

Внесем некоторые изменения в оригинальный репозиторий hello, чтобы затем попытаться извлечь и слить изменения из удаленной ветки в текущую.

Для этого перейдем в оригинальный репозиторий hello. (рис. [-@fig:109])

![Перейдем в оригинальный репозиторий hello](image/109.png){#fig:109 width=100%}

Внесем следующие изменения в файла README.md. (рис. [-@fig:110])
```md
This is the Hello World example from the git tutorial.
```

Теперь добавим это изменение и сделаем коммит. (рис. [-@fig:111])

![Проиндексируем и выполним коммит](image/111.png){#fig:111 width=100%}

Таким образом, в оригинальном репозитории есть более поздние изменения, которых нет в клонированной версии. 

Теперь научимся извлекать эти изменения из удаленного репозитория, выполнив (рис. [-@fig:112], рис. [-@fig:113]):

![Извлечем изменения из удаленного репозитория](image/112.png){#fig:112 width=100%}

![Извлечем изменения из удаленного репозитория](image/113.png){#fig:113 width=100%}

Сейчас мы находимся в репозитории cloned_hello. На данный момент в репозитории есть все коммиты из оригинального репозитория, но они не интегрированы в локальные ветки клонированного репозитория.

В истории выше найдем коммит «Changed README in original repo». Обратим внимание, что коммит включает в себя коммиты «origin/main» и «origin/HEAD». 

Теперь давайте посмотрим на коммит «Updated index.html». Можно увидеть, что локальная ветка main указывает на этот коммит, а не на новый коммит, который мы только что извлекли. 

Теперь мы можем продемонстрировать, что клонированный файл README.md не изменился, выполнив (рис. [-@fig:114]):

![Содержимое файла README.md](image/114.png){#fig:114 width=100%}

## Слияние извлеченных изменений

Сольем извлеченные изменения в локальную ветку main, выполнив (рис. [-@fig:115]):

![Сольем извлеченные изменения в локальную ветку main](image/115.png){#fig:115 width=100%}

Сейчас мы должны увидеть изменения, для этого выполним (рис. [-@fig:116]):

![Содержимое файла README.md](image/116.png){#fig:116 width=100%}

Хотя команда git fetch не сливает изменения, мы можем вручную слить изменения из удаленного репозитория.

Теперь давайте рассмотрим объединение fetch и merge в одну команду. (рис. [-@fig:117])

![Вручную сольем изменения из удаленного репозитория](image/117.png){#fig:117 width=100%}

Это эквивалентно двум следующим шагам:
```bash
git fetch
git merge origin/main
```

## Добавление ветки наблюдения

Ветки, которые начинаются с remotes/origin являются ветками оригинального репозитория. Обратим внимание, что у вас больше нет ветки под названием style, но система контроля версий знает, что в оригинальном репозитории ветка style была.

Добавим локальную ветку, которая отслеживает удаленную ветку, для этого выполним следующие команды (рис. [-@fig:118]):

![Добавим ветку наблюдения](image/118.png){#fig:118 width=100%}

Теперь мы можем видеть ветку style в списке веток и логе.

## Чистые репозитории

Чистые репозитории (без рабочих каталогов) обычно используются для расшаривания. Обычный git-репозиторий подразумевает, что вы будете использовать его как рабочую директорию, поэтому вместе с файлами проекта в актуальной версии, git хранит все служебные, «чисто-репозиториевские» файлы в поддиректории .git. В удаленных репозиториях нет смысла хранить рабочие файлы на диске (как это делается в рабочих копиях), а все что им действительно нужно — это дельты изменений и другие бинарные данные репозитория. Вот это и есть «чистый репозиторий».

## Создайте чистый репозиторий

Создадим чистый репозиторий. (рис. [-@fig:119])

![Создадим чистый репозиторий](image/119.png){#fig:119 width=100%}

Сейчас мы находимся в рабочем каталоге. Как правило, репозитории, оканчивающиеся на .git являются чистыми репозиториями. Мы видим, что в репозитории hello.git нет рабочего каталога. По сути, это есть не что иное, как каталог .git нечистого репозитория.

## Добавление удаленного репозитория

Давайте добавим репозиторий hello.git к нашему оригинальному репозиторию. (рис. [-@fig:120])

![Добавление репозитория hello.git к нашему оригинальному репозиторию hello](image/120.png){#fig:120 width=100%}

## Отправка изменений

Так как чистые репозитории, как правило, расшариваются на каком-нибудь сетевом сервере, нам необходимо отправить наши изменения в другие репозитории. Начнем с создания изменения для отправки. 

Отредактируем файл README.md. 
```md
This is the Hello World example from the git tutorial.
(Changed in the original and pushed to shared)
```

Теперь добавим это изменение и сделаем коммит. (рис. [-@fig:121])

![Проиндексируем и выполним коммит](image/121.png){#fig:121 width=100%}

Теперь отправим эти изменения в общий репозиторий. (рис. [-@fig:122])

![Отправим эти изменения в общий репозиторий](image/122.png){#fig:122 width=100%}

Общим называется репозиторий, получающий отправленные нами изменения.

## Извлечение общих изменений

Теперь научимся извлекать изменения из общего репозитория. 

Для этого переключимся в клонированный репозиторий. (рис. [-@fig:123])

![Клонированный репозиторий](image/123.png){#fig:123 width=100%}

 Далее извлечем изменения, только что отправленные в общий репозиторий. (рис. [-@fig:124])

![Извлечение общих изменений](image/124.png){#fig:124 width=100%}

Как мы можем заметить, изменения были успешно ивзлечены.

# Выводы

Научился создавать репозитории в github, использовать Git Bash, загружать файлы и папки на GitHub с помощью Git Bash.

# Список литературы

- Кулябов Д. С. *Лабораторная работа №1**: git.pdf*
- Кулябов Д. С. *Лабораторная работа №1**: markdown.pdf*